{
    "id": "hianime",
    "name": "HiAnime",
    "description": "HiAnime is an online streaming provider for subbed/dubbed animes in English",
    "manifestURI": "https://raw.githubusercontent.com/shehajeez/seanime-extensions/refs/heads/main/online-streaming-providers/hianime/manifest.json",
    "version": "1.0.0",
    "author": "Shehajeez",
    "type": "onlinestream-provider",
    "language": "typescript",
    "lang": "en",
    "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n\nclass Provider {\n    private baseUrl = 'https://hianime.to'\n    private apiUrl = 'https://api.hianime.to'\n\n    getSettings(): Settings {\n        return {\n            episodeServers: ['vidstreaming', 'streamsb', 'vidcloud'],\n            supportsDub: true\n        }\n    }\n\n    async search(opts: SearchOptions): Promise<SearchResult[]> {\n        try {\n            const params = new URLSearchParams({\n                keyword: opts.query,\n                dub: opts.dub ? '1' : '0'\n            })\n            if (opts.year) params.append('year', opts.year.toString())\n\n            const response = await fetch(`${this.apiUrl}/search?${params}`)\n            const data = await response.json()\n\n            return data.results.map((item: any) => ({\n                id: item.id,\n                title: item.title,\n                url: `${this.baseUrl}/watch/${item.id}`,\n                subOrDub: item.hasDub ? (item.hasSub ? 'both' : 'dub') : 'sub'\n            }))\n        } catch (error) {\n            console.error('Search error:', error)\n            return []\n        }\n    }\n\n    async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n        try {\n            const response = await fetch(`${this.apiUrl}/anime/${id}/episodes`)\n            const data = await response.json()\n\n            return data.episodes.map((ep: any) => ({\n                id: ep.id,\n                number: ep.number,\n                url: `${this.baseUrl}/watch/${id}/${ep.id}`,\n                title: ep.title || `Episode ${ep.number}`\n            }))\n        } catch (error) {\n            console.error('Find episodes error:', error)\n            return []\n        }\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, server: string): Promise<EpisodeServer> {\n        try {\n            const response = await fetch(`${this.apiUrl}/episode/${episode.id}/servers`)\n            const data = await response.json()\n\n            const selectedServer = data.servers.find((s: any) => s.name.toLowerCase() === server.toLowerCase()) \n                || data.servers[0]\n\n            const sources = await this.extractSources(selectedServer.url)\n\n            return {\n                server: selectedServer.name.toLowerCase(),\n                headers: {},\n                videoSources: sources\n            }\n        } catch (error) {\n            console.error('Find episode server error:', error)\n            return {\n                server: server,\n                headers: {},\n                videoSources: []\n            }\n        }\n    }\n\n    private async extractSources(url: string): Promise<VideoSource[]> {\n        try {\n            const response = await fetch(url)\n            const data = await response.json()\n            \n            const sources: VideoSource[] = []\n            \n            if (data.sources) {\n                for (const source of data.sources) {\n                    if (source.url.includes('.m3u8')) {\n                        const m3u8Response = await fetch(source.url)\n                        const m3u8Data = await m3u8Response.text()\n                        const qualities = this.parseM3u8Qualities(m3u8Data, source.url)\n                        sources.push(...qualities)\n                    } else {\n                        sources.push({\n                            url: source.url,\n                            type: 'mp4',\n                            quality: source.quality || 'unknown',\n                            subtitles: data.subtitles?.map((sub: any) => ({\n                                id: sub.id || '',\n                                url: sub.url,\n                                language: sub.language,\n                                isDefault: sub.default || false\n                            })) || []\n                        })\n                    }\n                }\n            }\n\n            return sources\n        } catch (error) {\n            console.error('Extract sources error:', error)\n            return []\n        }\n    }\n\n    private parseM3u8Qualities(m3u8Data: string, baseUrl: string): VideoSource[] {\n        const qualities: VideoSource[] = []\n        const lines = m3u8Data.split('\\n')\n        const baseUrlPath = baseUrl.substring(0, baseUrl.lastIndexOf('/'))\n\n        for (let i = 0; i < lines.length; i++) {\n            if (lines[i].includes('RESOLUTION=')) {\n                const quality = lines[i].match(/RESOLUTION=\\d+x(\\d+)/)?.[1]\n                const url = lines[i + 1].startsWith('http') \n                    ? lines[i + 1] \n                    : `${baseUrlPath}/${lines[i + 1]}`\n\n                if (quality && url) {\n                    qualities.push({\n                        url: url,\n                        type: 'm3u8',\n                        quality: `${quality}p`,\n                        subtitles: []\n                    })\n                }\n            }\n        }\n\n        return qualities\n    }\n}"
} 
