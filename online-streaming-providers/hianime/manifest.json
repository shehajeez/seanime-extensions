{
    "id": "hianime",
    "name": "HiAnime",
    "description": "HiAnime is an online streaming provider for subbed/dubbed animes in English",
    "manifestURI": "https://raw.githubusercontent.com/shehajeez/seanime-extensions/refs/heads/main/online-streaming-providers/hianime/manifest.json",
    "version": "1.0.1",
    "author": "Shehajeez",
    "type": "onlinestream-provider",
    "language": "typescript",
    "lang": "en",
    "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n\nclass Provider {\n    private baseUrl = 'https://hianime.to'\n    private apiUrl = 'https://api.hianime.to'\n\n    getSettings(): Settings {\n        return {\n            episodeServers: ['megacloud', 'vidstreaming', 'streamtape'],\n            supportsDub: true\n        }\n    }\n\n    async search(opts: SearchOptions): Promise<SearchResult[]> {\n        try {\n            const params = new URLSearchParams({\n                keyword: opts.query,\n                page: '1'\n            })\n\n            const response = await fetch(`${this.baseUrl}/search?${params}`, {\n                headers: {\n                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',\n                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8'\n                }\n            })\n\n            if (!response.ok) return []\n            const html = await response.text()\n            const results: SearchResult[] = []\n\n            const itemRegex = /<div class=\"flw-item\"[\\s\\S]*?<\\/div>/g\n            const items = html.match(itemRegex) || []\n\n            for (const item of items) {\n                const titleMatch = item.match(/data-jname=\"([^\"]+)\"/) \n                const idMatch = item.match(/href=\"\\/([^\"?]+)/)\n                const dubMatch = item.match(/class=\"tick-dub\"/)\n                const subMatch = item.match(/class=\"tick-sub\"/)\n\n                if (!titleMatch || !idMatch) continue\n\n                const id = idMatch[1]\n                const title = titleMatch[1]\n                const hasDub = !!dubMatch\n                const hasSub = !!subMatch\n\n                results.push({\n                    id,\n                    title,\n                    url: `${this.baseUrl}/watch/${id}`,\n                    subOrDub: hasDub ? (hasSub ? 'both' : 'dub') : 'sub'\n                })\n            }\n\n            return results\n        } catch (error) {\n            console.error('Search error:', error)\n            return []\n        }\n    }\n\n    async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n        try {\n            const showId = id.split('-').pop()\n            const response = await fetch(`${this.baseUrl}/ajax/v2/episode/list/${showId}`, {\n                headers: {\n                    'X-Requested-With': 'XMLHttpRequest',\n                    'Referer': `${this.baseUrl}/watch/${id}`\n                }\n            })\n            \n            if (!response.ok) return []\n            const data = await response.json()\n            const episodes: EpisodeDetails[] = []\n\n            const episodeRegex = /<a[^>]+data-number=\"(\\d+)\"[^>]+data-id=\"([^\"]+)\"[^>]*>(?:[\\s\\S]*?<div class=\"ssli-detail\">[\\s\\S]*?<span[^>]*>([^<]+)<\\/span>)?/g\n            let match\n\n            while ((match = episodeRegex.exec(data.html)) !== null) {\n                episodes.push({\n                    id: match[2],\n                    number: parseInt(match[1]),\n                    url: `${this.baseUrl}/ajax/v2/episode/servers?episodeId=${match[2]}`,\n                    title: match[3] ? match[3].trim() : `Episode ${match[1]}`\n                })\n            }\n\n            return episodes.sort((a, b) => a.number - b.number)\n        } catch (error) {\n            console.error('Find episodes error:', error)\n            return []\n        }\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, server: string): Promise<EpisodeServer> {\n        try {\n            const response = await fetch(episode.url)\n            if (!response.ok) throw new Error('Failed to fetch servers')\n            \n            const data = await response.json()\n            const serverRegex = /data-id=\"([^\"]+)\"[^>]+data-server-id=\"([^\"]+)\"[^>]+data-type=\"([^\"]+)\"[^>]*>[\\s\\S]*?<span>([^<]+)<\\/span>/g\n            const servers: Array<{id: string, serverId: string, type: string, name: string}> = []\n            \n            let match\n            while ((match = serverRegex.exec(data.html)) !== null) {\n                servers.push({\n                    id: match[1],\n                    serverId: match[2],\n                    type: match[3],\n                    name: match[4].toLowerCase()\n                })\n            }\n\n            const selectedServer = servers.find(s => s.name === server.toLowerCase()) || servers[0]\n            if (!selectedServer) throw new Error('Server not found')\n\n            const sources = await this.extractSources(selectedServer.id, selectedServer.type)\n\n            return {\n                server: selectedServer.name,\n                headers: {\n                    'Referer': this.baseUrl,\n                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36'\n                },\n                videoSources: sources\n            }\n        } catch (error) {\n            console.error('Find episode server error:', error)\n            return {\n                server: server,\n                headers: {},\n                videoSources: []\n            }\n        }\n    }\n\n    private async extractSources(serverId: string, type: string): Promise<VideoSource[]> {\n        try {\n            const response = await fetch(`${this.baseUrl}/ajax/v2/episode/sources?id=${serverId}`)\n            if (!response.ok) throw new Error('Failed to fetch sources')\n            \n            const data = await response.json()\n            const decrypted = await this.decryptSource(data.link)\n            \n            const sources: VideoSource[] = []\n            \n            if (decrypted.sources) {\n                for (const source of decrypted.sources) {\n                    if (source.file.includes('.m3u8')) {\n                        const m3u8Response = await fetch(source.file)\n                        const m3u8Data = await m3u8Response.text()\n                        const qualities = this.parseM3u8Qualities(m3u8Data, source.file)\n                        sources.push(...qualities)\n                    } else {\n                        sources.push({\n                            url: source.file,\n                            type: source.type === 'hls' ? 'm3u8' : 'mp4',\n                            quality: source.label || 'unknown',\n                            subtitles: decrypted.tracks?.map(track => ({\n                                id: track.file,\n                                url: track.file,\n                                language: track.label,\n                                isDefault: track.default || false\n                            })) || []\n                        })\n                    }\n                }\n            }\n\n            return sources\n        } catch (error) {\n            console.error('Extract sources error:', error)\n            return []\n        }\n    }\n\n    private async decryptSource(url: string): Promise<any> {\n        try {\n            const response = await fetch(url)\n            const data = await response.json()\n            \n            if (!data.sources) {\n                const decrypted = await this.decryptMegacloud(data.data)\n                return decrypted\n            }\n            \n            return data\n        } catch (error) {\n            console.error('Decrypt source error:', error)\n            return { sources: [], tracks: [] }\n        }\n    }\n\n    private async decryptMegacloud(encryptedData: string): Promise<any> {\n        try {\n            const decrypted = await this.extractMegacloudSources(encryptedData)\n            return decrypted\n        } catch (error) {\n            console.error('Megacloud decrypt error:', error)\n            return { sources: [], tracks: [] }\n        }\n    }\n\n    private async extractMegacloudSources(encryptedData: string): Promise<any> {\n        const keys = {\n            key: \"37911490979715163134003223491201\",\n            secondKey: \"54674138327930866480207815084989\",\n            iv: \"3134003223491201\"\n        }\n\n        try {\n            const decryptedData = this.decryptAES(encryptedData, keys.key, keys.iv)\n            const decryptedJson = JSON.parse(decryptedData)\n            \n            if (decryptedJson.source) {\n                return {\n                    sources: decryptedJson.source,\n                    tracks: decryptedJson.track || []\n                }\n            }\n            \n            const decryptedData2 = this.decryptAES(encryptedData, keys.secondKey, keys.iv)\n            const decryptedJson2 = JSON.parse(decryptedData2)\n            \n            return {\n                sources: decryptedJson2.source || [],\n                tracks: decryptedJson2.track || []\n            }\n        } catch (error) {\n            throw error\n        }\n    }\n\n    private decryptAES(encrypted: string, key: string, iv: string): string {\n        const decrypted = CryptoJS.AES.decrypt(encrypted, CryptoJS.enc.Utf8.parse(key), {\n            iv: CryptoJS.enc.Utf8.parse(iv),\n            mode: CryptoJS.mode.CBC,\n            padding: CryptoJS.pad.Pkcs7\n        })\n        return decrypted.toString(CryptoJS.enc.Utf8)\n    }\n\n    private parseM3u8Qualities(m3u8Data: string, baseUrl: string): VideoSource[] {\n        const qualities: VideoSource[] = []\n        const lines = m3u8Data.split('\\n')\n        const baseUrlPath = baseUrl.substring(0, baseUrl.lastIndexOf('/'))\n\n        for (let i = 0; i < lines.length; i++) {\n            if (lines[i].includes('RESOLUTION=')) {\n                const quality = lines[i].match(/RESOLUTION=\\d+x(\\d+)/)?.[1]\n                const url = lines[i + 1].startsWith('http') \n                    ? lines[i + 1] \n                    : `${baseUrlPath}/${lines[i + 1]}`\n\n                if (quality && url) {\n                    qualities.push({\n                        url: url,\n                        type: 'm3u8',\n                        quality: `${quality}p`,\n                        subtitles: []\n                    })\n                }\n            }\n        }\n\n        return qualities\n    }\n\n    async getAnimeInfo(id: string): Promise<any> {\n        try {\n            const [animeResponse, characterResponse] = await Promise.all([\n                fetch(`${this.baseUrl}/${id}`),\n                fetch(`${this.baseUrl}/ajax/character/list/${id.split('-').pop()}`)\n            ])\n\n            if (!animeResponse.ok || !characterResponse.ok) throw new Error('Failed to fetch anime info')\n\n            const animeHtml = await animeResponse.text()\n            const characterData = await characterResponse.json()\n\n            const titleRegex = /<h2 class=\"film-name\"[^>]*>([^<]+)<\\/h2>/\n            const japTitleRegex = /<h2 class=\"film-name\"[^>]*data-jname=\"([^\"]+)\"/\n            const posterRegex = /<img src=\"([^\"]+)\"[^>]*class=\"film-poster-img\"/\n            const typeRegex = /<div class=\"tick-item tick-type\">([^<]+)<\\/div>/\n            const qualityRegex = /<div class=\"tick-item tick-quality\">([^<]+)<\\/div>/\n            const subDubRegex = /<div class=\"tick-item tick-(sub|dub)\">([^<]+)<\\/div>/g\n            const ratingRegex = /<div class=\"tick-item tick-pg\">([^<]+)<\\/div>/\n            const overviewRegex = /<div class=\"text\"[^>]*>([^<]+)<\\/div>/\n\n            const title = animeHtml.match(titleRegex)?.[1]?.trim()\n            const japaneseTitle = animeHtml.match(japTitleRegex)?.[1]\n            const poster = animeHtml.match(posterRegex)?.[1]\n            const type = animeHtml.match(typeRegex)?.[1]?.trim()\n            const quality = animeHtml.match(qualityRegex)?.[1]?.trim()\n            const rating = animeHtml.match(ratingRegex)?.[1]?.trim()\n\n            let subDub = { sub: false, dub: false }\n            let match\n            while ((match = subDubRegex.exec(animeHtml)) !== null) {\n                subDub[match[1]] = true\n            }\n\n            const overview = animeHtml.match(overviewRegex)?.[1]?.trim()\n\n            const characterRegex = /<div class=\"bac-item\">[\\s\\S]*?<img[^>]*data-src=\"([^\"]+)\"[^>]*>[\\s\\S]*?<h4[^>]*>([^<]+)<\\/h4>[\\s\\S]*?<div class=\"pi-cast\">([^<]+)<\\/div>/g\n            const characters = []\n            while ((match = characterRegex.exec(characterData.html)) !== null) {\n                characters.push({\n                    image: match[1],\n                    name: match[2].trim(),\n                    role: match[3].trim()\n                })\n            }\n\n            return {\n                title,\n                japaneseTitle,\n                poster,\n                type,\n                quality,\n                subOrDub: subDub.dub ? (subDub.sub ? 'both' : 'dub') : 'sub',\n                rating,\n                overview,\n                characters\n            }\n\n        } catch (error) {\n            console.error('Get anime info error:', error)\n            return null\n        }\n    }\n}"
} 
